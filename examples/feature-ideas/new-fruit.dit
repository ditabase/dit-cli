// A series of cartoonish dits to demonstrate dit syntax.

// A dit class
class Fruit {|
    // A class attribute. Unsurprisingly, its a list of strings.
    listOf String knownFruits = ['apple', 'banana', 'pear', 'clementine', 'kiwi'];

    /*  
        String is the only primitive type. If you want something more complicated,
        you need to implement it yourself, since primitives have so much variation.
        Lists are not checked for shape (1D, 2D, jagged), just that they are lists.
    */
    
    /*  
        Short function signature. 'func', then name, then params.
        Also -dashCase- for all reserved functions.
        I don't think -dashCase- looks very good, but it works, and I can change it.
        The important thing is that -dashFunctions- are special.
        'Make' is the current reserved name for constructors, subject to change
    */
    func Make(String val) {|
        // Instance attribute.
        String this.myFruit = val;
        /* 
            Ditlang has no ifs, loops, or complex concepts of any kind.
            It can assign values and call functions and nothing else.
            All the real work is done by other languages.
        */
    |}

    // Built-in method for telling this instance to do whatever it needs to do.
    // Since fruit is just a data object, it should validate itself on run.
    func Run() {|
        this.validate();
    |}

    // Language agnostic scripting.
    // sig defines switches, which can be very long.
    // "sig LANG RETURN_TYPE STATIC/INSTANCE ...""
    // by default, lang is DitLang, return is void, and function is Instance
    sig Python
    func validate() {|
        # A "Triangle Expression"
        value = <|this.myFruit|>
        fruits = <|this.knownFruits|>

        # Triangle Expressions are for communicating with dit inside of other languages.
        # In this case, it will write the literal value of "myFruit"
        # into the Python source code as a string (value = 'kiwi')
        # It understands lists and objects as well, so it will write 
        # ['apple', 'banana'] or {"label1": "value1"} as needed.

        # Adding a language only requires a configuration file
        # to explain syntax and other meta data.

        if len(fruits) != len(set(fruits)):
            <|throw "The list of fruits must be unique"|>
            # Another Triangle Expression, executing a 'throw' command.
            # For now, exceptions are just strings. 

        if value not in fruits:
            <|throw (|f'"{value}" is not a valid fruit.'|)|>
            # This Triangle expression is a little different
            # It contains a Circle Expression where you can use the language again.
            # Dit will execute the code and use it as an argument for the command.
            
        # Review:
        # Triangle Expression: Pull info from dit, execute dit commands.
        # Circle Expression: Send info back to dit, arguments for dit commands.
    |}

    // Language overloading, this could be run in a browser or other non-Python context.
    sig JavaScript
    func validate() {|
        const value = <|this.myFruit|>; // Notice the Shape Expressions look the same,
        const fruits = <|this.knownFruits|>; // except for the semicolon.

        if (fruits.length !== new Set(fruits).size) {
            <|throw "The list of fruits must be unique"|>
            // Triangle Expressions with commands do not need to end in a semicolon
            // or otherwise conform to the surrounding code. Think of them as
            // though they represent several lines of normal language code.
        }

        if (fruits.indexOf(value) === -1) { 
            <|throw (|`"${value}" is not a valid fruit.`;|)|>
        }
    |}

    // Compiled languages are not implemented yet, but will work fine in the future.
    sig Java
    func validate() {|
        // pre will blindly place whatever you want at the top of the file.
        <|pre (|import java.util.Arrays;|)|>

        String value = <|this.myFruit|>;
        String[] fruits = <|this.knownFruits|>;
        // Dit knows Java is different, will write {"apple", "banana", "etc"}

        if (!Arrays.asList(fruits).contains(value)) {
            <|throw (|"\"" + value + "\" is not a valid fruit.";|)|>
        }

        List<String> fruits = Arrays.asList(new String[]<|this.myFruits|>);
        String value = <|this.value|>;

        if(fruits.size() != new HashSet<String>(fruits).size()) {
            <|throw "The list of fruits must be unique"|>
        }

        if (!fruits.contains(value)) {
            <|throw (|"\"" + value + "\" is not a valid fruit.";|)|>
        }
    |}

    // If multiple languages are available, there will be options to choose
    // a specific one, a preference hierarchy, or just the fastest one.
    // If no implementation is compatible (in a browser, but no JavaScript version),
    // then dit can request a server to execute the code remotely, or fail.
    
    // You can "transpile" most languages to most other languages, in case you need
    // all client side code, (no internet connection, sensitive private data).
    // Your dit data will still be compatible with the greater DitaBase ecosystem.

    func Ditlang String -str-() {|
        return this.value;
    |}
|}

// Declaration/instantiation.
Fruit goodFruit = Fruit('kiwi');

// Would throw an error if validated.
Fruit badFruit = Fruit('Clearly not a fruit');

// We aren't validating these objects yet, or even in Make
// That's because of this:
func Run() {|
    dit.runAll();
    /*
        We are assigning the Run function for this entire dit,
        which can be referenced explicitly with -dit-.Run()
        It calls -runA
    	This will activate the Run() function of all objects in this dit
    	They activate in parallel, so if you have a large number of similar objects
    	which all need to do something, -runAll-() is perfect.
    	It makes more sense to validate all objects at once, if you can wait,
    	since -runAll- has optimizations built in.
        We'll call this function at the end of the dit.
    */
    print("dit is valid, no errors found");
|}

// Let's see a bit more complexity
class FruitPref {|
    func Make(Fruit least, Fruit most) {|
        // Attributes of another class type. 
        Fruit this.leastFav = least;
        Fruit this.mostFav = most;
        // Note the "no use before define." That's why Fruit is above.
        // Also note that the class name is available in this scope.
        // All variables in the outer scope will be available, recursively.
    |}

    func Run() {|
        this.validate();
    |}

    sig JavaScript
    func validate() {|
        if (<|this.mostFav.myFruit|> === <|this.leastFav.myFruit|>) {
            <|throw (|"Your most and least favorite fruits cannot be the same."|)|>
        }
    |}

    sig Python String
    func -str-() {|
        ret = f"I like {<|this.mostFav.value|>}, but hate {<|this.leastFav.value|>}."
        <|return (|ret|)|>
    |}
|}

FruitPref favorites = FruitPref(goodFruit, Fruit('apple'));

// Load dit classes from HTTP or local file system.
// This is a simple implementation for JavaScript style numbers.
import NumberNamespace from
"https://raw.githubusercontent.com/ditabase/dits/master/new-dits/Number.dit";

// You can imagine lots of small utility classes like this.
SomeDataLogger {|
    func Make() {|
        ImportedNamespace.Number this.ops = ImportedNamespace.Number('0');
        listOf String opLog = [];
    |}

    func log(String message) {|
        this.operations.inc();
        this.opLog += message;
    |}

    func log() {|
        this.log("anonymous");
    |}

    sig Python String
    func -str-() {|
        output = ""
        for message, index in Enumerate(<|this.opLog|>):
            output += f'Op #{index:2} - {message}\n';
        return output[:-1] # strip trailing newline.
    |}
|}

// How about inheritance?
class FoodSatisfaction {|
    Parents = [FruitPref, SomeDataLogger];
    // Inheritance is just a list. The order of the list determines MRO precedence.
    // It's dynamic, meaning any script can add and remove parents as needed.

    // The intention is that a class can inherit from many unrelated
    // and non-conflicting classes, and scripts can easily tack on extra classes.
    // I can imagine a class having 50 parent classes for utility or compliance,
    // none of which have any name conflicts.

    func Make(Fruit least, Fruit most) {|
        this.FruitPref.Make(least, most);
        // Explicitly reference the parent class's constructor method.

        // this.Make(least, most); // This is just recursion
        // The local constructor hides the constructor of the parent
        // TODO: Explain this bit in more detail

        SomeDataLogger.Make();
        Number this.satisfaction = Number('0');
    |}

    // No Run is needed. This class only responds to class functions

    sig Python
    func eat(String food) {|
        least = <|this.leastFav|>
        most = <|this.mostFav|>

        # Creating another object on the fly and running it.
        <|Fruit(food).Run()|>

        # This will call validate() for the food string,
        # and anything else Run() might do in the future.
        # It's important to validate it since it might come from the command line.

        food = <|food|>

        if food == least:
            <|this.satisfaction.sub('3')|>
            <|this.log("ate least")|>
        elif food == most:
            <|this.satisfaction.add('3')|>
            <|this.log("ate most")|>
        else:
            <|this.satisfaction.add('1')|>
            <|this.log("ate neutral")|>
    |}

    func -str-() {|
        // Unsure about String concatenation syntax, but this is pretty uncontroversial.
        return "Satisfaction: " + this.satisfaction + "\nMeals: " + this.ops + "\n"; 
    |}
|}

FruitSatisfaction sat = FruitSatisfaction("pear", "banana");
sat.eat("pear");
sat.eat("apple");
sat.eat("banana");
sat.eat("clementine"); // Note when this occurs, it will be important in a bit.

// Also note, I'm mixing data classes that do nothing but store and validate data
// and more functional classes that can have state mutations and perform actions.
// They probably would normally be separated.

// Top level function, demonstrating lack of privacy in dit.
// Anything can mess with anything else, at any time.
sig Python Fruit
func aggressiveFruitSwitch(String newFruit, String oldFruit) {|
    fruits = <|Fruit.knownFruits|>
    newFruit = <|newFruit|>
    oldFruit = <|oldFruit|>

    if newFruit == oldFruit:
        <|throw "The new and old fruits should be different."|>

    # Now let's add newFruit to the list and remove the old one.
    if not newFruit in fruits:
        fruits.append(newFruit)
        <|Fruit.knownFruits = (|fruits|)|> # Editing class attribute! Yikes!

    if oldFruit in fruits:
        fruits.remove(oldFruit):
        <|Fruit.knownFruits = (|fruits|)|>
    # This could obviously lead to bugs, race conditions, and confusing code,
    # but that is for the programmer to figure out. If someone really needs
    # to modify other dits and code, even given the risks and costs, they can.

    # Remember, however, that so far, this is all local to the current dit.
    # You can also do this:
    String ImportedNamespace.Number.SomeImportantValue = 'Very Aggressive Change';

    # This basically let's anyone "fork" an imported dit, directly in dit syntax.
    # This could also be used for backwards compatibility and modernizing old dits.
    # A 15 year old dit could be kept working just by running a script ahead of it
    # that fixes all of the bugs and converting things to modern standards.

    return <|Fruit(newFruit)|>
|}

aggressiveFruitSwitch("clementine", "orange");
sat.eat("orange"); // "clementine" was safe above, but now would cause an error.

dit.Run();
// With this line in the file, the dit will run as soon as it parses to this point.
// You could instead leave this out, and call Run() from the command line.
// If you have a huge dit which takes a long time to validate, but you already know
// it is valid, there's no need to validate it again if you're just running
// some sort of function or query.

// The whole point here is that it's entirely up to you how to solve problems with
// this, just like normal code. But because dit can be repurposed and reused for any
// problem, with any language, people can write dits intended for sharing.

// A serious data storage dit in the future might start with 50 lines of just import
// statements, then have 10,000 lines of JSON data. Then another 20,000 lines of 
// RDF. No source code at all, just using the imported dits to work with the data.

// Of course, dit is not just for data. There's no reason you couldn't code a database,
// a game, application, compiler, etc. directly within dit.